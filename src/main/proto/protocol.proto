syntax = "proto2";

package ca.yyx.hu.aap.protocol;

enum MessageStatus
{
    STATUS_OK = 0;
}

message ButtonInfo
{
    required uint32 scan_code = 1;
    required bool is_pressed = 2;
    required uint32 meta = 3;
    required bool long_press = 4;
}

message ButtonInfoWrapper
{
    repeated ButtonInfo button = 1;
}

message TouchInfo
{
    enum TOUCH_ACTION
    {
        RELEASE = 0;
        PRESS = 1;
        DRAG = 2;
    }
    message Location
    {
        required uint32 x = 1;
        required uint32 y = 2;
        required uint32 pointer_id = 3;
    }
    repeated Location location = 1;
    required uint32 action_index = 2;
    required TOUCH_ACTION action = 3;
}


message InputEvent
{
    required uint64 time_stamp = 1;
    optional int32 disp_channel = 2;
    optional TouchInfo touch = 3;
    optional ButtonInfoWrapper button = 4;
}

message BindingRequest
{
    repeated int32 scan_codes = 1;
}

message BindingResponse
{
    required MessageStatus status = 1;
}

enum SensorType
{
    SENSOR_TYPE_DRIVING_STATUS = 11;
    SENSOR_TYPE_NIGHT_DATA = 10;
    SENSOR_TYPE_RPM = 3;
    SENSOR_TYPE_DIAGNOSTICS = 8;
    SENSOR_TYPE_GEAR = 7;
    SENSOR_TYPE_COMPASS = 1;
    SENSOR_TYPE_LOCATION = 9;
}

message SensorBatch
{
    message LocationData
    {
        optional int64 timestamp = 1;
        optional int32 latitude = 2;
        optional int32 longitude = 3;
        optional int32 accuracy = 4;
        optional int32 altitude = 5;
        optional int32 speed = 6;
        optional int32 bearing = 7;
    }
    message NightMode
    {
        required bool is_night = 1;
    }
    message DrivingStatus
    {
        required int32 is_driving = 1;
    }

    repeated LocationData location_data = 1;
    //repeated CompassData compass_data = 2;
    //repeated Speed = 3;
    //repeated RPM = 4;
    //repeated Odometer = 5;
    //repeated Fuel = 6;
    //repeated ParkingBreak = 7;
    //repeated GearData = 8;
    //repeated Diagnostics = 9;
    repeated NightMode night_mode = 10;
    //repeated Environment = 11;
    //repeated HVAC = 12;
    repeated DrivingStatus driving_status = 13;
    //repeated DeadReckoning = 14;
    //repeated Passenger = 15;
    //repeated Door = 16;
    //repeated Light = 17;
    //repeated Tire = 18;
    //repeated Accel = 19;
    //repeated Gyro = 20;
    //repeated GPS = 21;
}

enum AUDIO_TYPE
{
    AUDIO_TYPE_SPEECH = 1;
    AUDIO_TYPE_SYSTEM = 2;
    AUDIO_TYPE_MEDIA = 3;
}

enum STREAM_TYPE
{
    STREAM_TYPE_AUDIO = 1;
    STREAM_TYPE_VIDEO = 3;
}

message AudioConfiguration
{
    optional uint32 sample_rate = 1;
    required uint32 number_of_bits = 2;
    required uint32 number_of_channels = 3;
}

message Service
{
    optional uint32 id = 1;
    message SensorSourceService
    {
        message Sensor
        {
            required SensorType type = 1;
        }
        repeated Sensor sensors = 1;
    }
    optional SensorSourceService sensor_source_service = 2;

    message MediaSinkService
    {
        optional STREAM_TYPE available_type = 1;
        optional AUDIO_TYPE audio_type = 2;
        repeated AudioConfiguration audio_configs = 3;

        message VideoConfig
        {
            enum VIDEO_RESOLUTION
            {
                VIDEO_RESOLUTION_800x480 = 1;
                VIDEO_RESOLUTION_1280x720 = 2;
                VIDEO_RESOLUTION_1920x1080 = 3;
            }

            enum VIDEO_FPS
            {
                VIDEO_FPS_30 = 1;
                VIDEO_FPS_60 = 2;
            }
            required VIDEO_RESOLUTION resolution = 1;
            required VIDEO_FPS frame_rate = 2;
            required uint32 margin_width = 3;
            required uint32 margin_height = 4;
            required uint32 dpi = 5;
            optional uint32 additional_depth = 6;
        }
        repeated VideoConfig video_configs = 4;
        optional bool available_while_in_call = 5;
    }
    optional MediaSinkService media_sink_service = 3;

    message InputSourceService
    {
        message TouchConfig
        {
            required uint32 width = 1;
            required uint32 height = 2;
        }
        repeated uint32 keycodes_supported = 1;
        optional TouchConfig touchscreen = 2;
        optional TouchConfig touchpad = 3;
    }

    optional InputSourceService input_source_service = 4;

    message MediaSourceService
    {
        required STREAM_TYPE type = 1;
        required AudioConfiguration audio_config = 2;
        optional bool available_while_in_call = 3;
    }

    optional MediaSourceService media_source_service = 5;

    message BluetoothService {
        enum BluetoothPairingMethod
        {
            BLUETOOTH_PARING_METHOD_1 = 1;
            BLUETOOTH_PARING_METHOD_2 = 2;
            BLUETOOTH_PARING_METHOD_3 = 3;
            BLUETOOTH_PARING_METHOD_4 = 4;
        }
        required string car_address = 1;
        repeated BluetoothPairingMethod supported_pairing_methods = 2;
    }
    optional BluetoothService bluetooth_service = 6;

    //radio_service = 7
    //navigation_status_service=8
    //media_playback_service == 9
    //phone_status_service = 10
    //media_browser_service=11
    //vendor_extension_service==12
    //generic_notification_service==13
}

message ServiceDiscoveryRequest
{
    optional string phone_name = 4;
}

message ServiceDiscoveryResponse
{
    repeated Service services = 1;
    optional string make = 2;
    optional string model = 3;
    optional string year = 4;
    optional string vehicle_id = 5;
    optional bool driver_position = 6;
    optional string head_unit_make = 7;
    optional string head_unit_model = 8;
    optional string head_unit_software_build = 9;
    optional string head_unit_software_version = 10;
    optional bool can_play_native_media_during_vr = 11;
    optional bool hide_projected_clock = 12;
}

message ChannelOpenRequest
{
    optional int32 priority = 1;
    optional int32 service_id = 2;
}

message ChannelOpenResponse
{
    required MessageStatus status = 1;
}

message PingRequest
{
    required int64 timestamp = 1;
}

message PingResponse
{
    required int64 timestamp = 1;
}

message ShutdownRequest
{
    enum REASON
    {
        REASON_QUIT = 1;
    }
    optional REASON reason = 1;
}

message ShutdownResponse
{

}

message MediaSetupRequest
{
    optional uint32 type = 1; //Enum?
}

message MediaSetupResponse
{
    enum MEDIA_STATUS
    {
        MEDIA_STATUS_1 = 1;
        MEDIA_STATUS_2 = 2;
    }
    required MEDIA_STATUS media_status = 1;
    required uint32 max_unacked = 2;
    repeated uint32 configs = 3;
}


message MediaStopRequest
{

}

message MediaStartRequest
{
    required int32 session = 1;
    optional uint32 config = 2;
}

message MediaAck
{
    required int32 session = 1;
    required uint32 value = 2;
}

message MicRequest
{
    required bool open = 1;
    optional bool anc = 2;
    optional bool ec = 3;
    required int32 max_unacked = 4;
}

message MicResponse
{
    required int32 session = 1;
    required uint32 value = 2;
}

enum VideoFocusMode
{
    VIDEO_FOCUS_MODE_1 = 1;
    VIDEO_FOCUS_MODE_2 = 2;
}

message VideoFocusRequestNotification
{
    enum VideoFocusReason
    {
        VIDEO_FOCUS_REASON_1 = 1;
        VIDEO_FOCUS_REASON_2 = 2;
    }

    optional int32 disp_channel_id = 1;
    optional VideoFocusMode mode = 2; //Enum?
    optional VideoFocusReason reason = 3; //Enum?
}

message VideoFocusNotification
{
    optional VideoFocusMode mode = 1;
    optional bool unsolicited = 2;
}

message SensorRequest
{
    optional SensorType type = 1;
    optional int64 min_update_period = 2;
}

message SensorResponse
{
    required MessageStatus status = 1;
}

message NavigationFocusRequest
{
    optional uint32 focus_type = 1; //Enum?
}

message NavigationFocusResponse
{
    optional uint32 focus_type = 1; //Enum?
}

message VoiceSessionNotification
{
    enum VoiceSessionStatus
    {
        VOICE_STATUS_START = 1;
        VOICE_STATUS_STOP = 2;
    }
    optional VoiceSessionStatus status = 1;
}

message AudioFocusRequestNotification
{
    enum AudioFocusRequestType
    {
        AUDIO_FOCUS_GAIN = 1;
        AUDIO_FOCUS_GAIN_TRANSIENT = 2;
        AUDIO_FOCUS_UNKNOWN = 3;
        AUDIO_FOCUS_RELEASE = 4;
    }
    optional AudioFocusRequestType request = 1;
}

message AudioFocusNotification
{
    enum AudioFocusStateType
    {
        AUDIO_FOCUS_STATE_GAIN = 1;
        AUDIO_FOCUS_STATE_GAIN_TRANSIENT = 2;
        AUDIO_FOCUS_STATE_LOSS = 3;
        AUDIO_FOCUS_STATE_LOSS_TRANSIENT_CAN_DUCK = 4;
        AUDIO_FOCUS_STATE_LOSS_TRANSIENT = 5;
        AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY = 6;
        AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY = 7;
    }
    optional AudioFocusStateType focus_state = 1;
    optional bool unsolicited = 2;
}